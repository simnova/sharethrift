/** biome-ignore-all lint/suspicious/noExplicitAny: temporary ignore warning for we are reusing current implementation in AHP; will address in future */
/** biome-ignore-all lint/suspicious/useAwait: temporary ignore warning for we are reusing current implementation in AHP; will address in future */
import type { ServiceBase } from '@cellix/api-services-spec';

// @ts-ignore
import cybersource from 'cybersource-rest-client';

import { randomUUID } from 'crypto';

import type {
	PaymentService,
	CustomerProfile,
	PaymentTokenInfo,
	PaymentTransactionResponse,
	CustomerPaymentResponse,
	CustomerPaymentInstrumentResponse,
	PaymentInstrumentInfo,
	TransactionReceipt,
	RefundPaymentResponse,
	CustomerPaymentInstrumentsResponse,
	PlanCreation,
	PlanCreationResponse,
	PlanResponse,
	Subscription,
	SubscriptionResponse,
	SubscriptionsListResponse,
	SuspendSubscriptionResponse,
	PlansListResponse,
  TransactionSearchResponse
} from '@cellix/payment-service';

export class PaymentServiceCybersource
	implements ServiceBase<PaymentServiceCybersource>, PaymentService
{
	private client: cybersource.ApiClient | undefined;
	private configObject: cybersource.Configuration;
	private readonly authenticationType: string = 'http_signature';
	private readonly applicationName: string = 'CYBERSOURCE_APP_NAME';
	private readonly merchantId: string = 'CYBERSOURCE_MERCHANT_ID';
	private readonly merchantKeyId: string = 'CYBERSOURCE_MERCHANT_KEY_ID';
	private readonly merchantKeySecret: string =
		'CYBERSOURCE_MERCHANT_KEY_SECRET';
	private readonly runEnvironment: string = 'CYBERSOURCE_RUN_ENVIRONMENT';
	private readonly enableLog: string = 'CYBERSOURCE_ENABLE_LOG';
	private readonly targetOrigin: string = 'CYBERSOURCE_IFRAME_TARGET_ORIGIN';

	constructor(
		applicationName?: string,
		merchantId?: string,
		merchantKeyId?: string,
		merchantKeySecret?: string,
		runEnvironment?: string,
		enableLog?: string,
		targetOrigin?: string,
	) {
		this.applicationName = applicationName ?? '';
		this.merchantId = merchantId ?? '';
		this.merchantKeyId = merchantKeyId ?? '';
		this.merchantKeySecret = merchantKeySecret ?? '';
		this.runEnvironment = runEnvironment ?? '';
		this.enableLog = enableLog ?? '';
		this.targetOrigin = targetOrigin ?? '';
		this.configObject = {
			authenticationType: this.authenticationType,
			runEnvironment: this.runEnvironment,
			merchantID: this.merchantId,
			merchantKeyId: this.merchantKeyId,
			merchantsecretKey: this.merchantKeySecret,
			logConfiguration: {
				enableLog: this.enableLog,
			},
		};

		if (
			!this.applicationName ||
			!this.merchantId ||
			!this.merchantKeyId ||
			!this.merchantKeySecret ||
			!this.runEnvironment ||
			!this.enableLog ||
			!this.targetOrigin
		) {
			console.warn(
				'PaymentServiceCybersource: All configuration keys must be provided. Service will not function until credentials are provided.',
			);
		}
	}

	public startUp(): Promise<
		Exclude<PaymentServiceCybersource, ServiceBase<PaymentServiceCybersource>>
	> {
		if (this.client) {
			throw new Error('PaymentServiceCybersource is already started');
		}
		if (process.env['NODE_ENV'] === 'development') {
			this.client = new cybersource.ApiClient();
		}
		return this as Exclude<
			PaymentServiceCybersource,
			ServiceBase<PaymentServiceCybersource>
		>;
	}

	public shutDown(): Promise<void> {
		this.client = undefined;
		return Promise.resolve();
	}

	public get service(): cybersource.ApiClient {
		if (!this.client) {
			throw new Error(
				'ServiceMessagingTwilio is not started - cannot access service',
			);
		}
		return this.client;
	}
	/**
	 * Generate a public key for the Cybersource API
	 *   - The key is used to encrypt the payment data
	 *   - The key is generated using the Cybersource API
	 * @returns {Promise<string>} The public key generated by the Cybersource API
	 * @throws {Error} If an error occurs in generating the public key
	 * full details: https://developer.cybersource.com/docs/barclays/en-us/digital-accept-flex/developer/all/rest/digital-accept-flex/microform-integ-v2/microform-integ-getting-started-v2.html
	 * */

	async generatePublicKey(): Promise<string> {
		const microformIntegration = new cybersource.MicroformIntegrationApi(
			this.configObject,
			this.client,
		);
		const generateCaptureContextReq =
			new cybersource.GenerateCaptureContextRequest();

		generateCaptureContextReq.targetOrigins = [this.targetOrigin]; // This is an array in Flex v2
		generateCaptureContextReq.encryptionType = 'RsaOaep256'; // Set the encryption type to RSA-OAEP-256

		return new Promise((resolve, reject) => {
			microformIntegration.generateCaptureContext(
				generateCaptureContextReq,
				(error: { message?: string }, data: any) => {
					if (error) {
						const normalizedError = new Error(
							error && typeof error === 'object' && error.message
								? error.message
								: 'Unknown error occurred in generating public key',
						);
						return reject(normalizedError);
					}

					resolve(typeof data === 'string' ? data : String(data));
				},
			);
		});
	}

	/**
	 * Create a customer using the Cybersource API
	 * - Creates customer profile and links the customer's payment information with customer profile
	 * @param {CustomerProfile} customerProfile The customer profile to be used for the customer profile
	 * @param {PaymentTokenInfo} paymentTokenInfo The payment token to be used for the customer profile
	 * @returns {Promise<PaymentTransactionResponse>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in creating the customer profile
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#payments
	 * */

	async createCustomerProfile(
		customerProfile: CustomerProfile,
		paymentTokenInfo: PaymentTokenInfo,
	): Promise<PaymentTransactionResponse> {
		const instance = new cybersource.PaymentsApi(
			this.configObject,
			this.client,
		);

		// create a new ClientReferenceInformation object used for reconciliation purposes (search)
		const clientReferenceCode = randomUUID();
		const clientReferenceInformation =
			new cybersource.Ptsv2paymentsClientReferenceInformation();
		clientReferenceInformation.code = clientReferenceCode;
		clientReferenceInformation.applicationName = this.applicationName;

		// create a new OrderInformationAmountDetails object
		const orderInformationAmountDetails =
			new cybersource.Ptsv2paymentsOrderInformationAmountDetails();
		orderInformationAmountDetails.totalAmount = '0'; // Zero amount for instrument identifier
		orderInformationAmountDetails.currency = 'USD';

		const orderInformationBillTo =
			new cybersource.Ptsv2paymentsOrderInformationBillTo();
		orderInformationBillTo.firstName = customerProfile.billingFirstName;
		orderInformationBillTo.lastName = customerProfile.billingLastName;
		orderInformationBillTo.address1 = customerProfile.billingAddressLine1;
		orderInformationBillTo.address2 = customerProfile.billingAddressLine2;
		orderInformationBillTo.locality = customerProfile.billingCity;
		orderInformationBillTo.administrativeArea = customerProfile.billingState;
		orderInformationBillTo.postalCode = customerProfile.billingPostalCode;
		orderInformationBillTo.country = customerProfile.billingCountry;
		orderInformationBillTo.email = customerProfile.billingEmail;
		orderInformationBillTo.phoneNumber = customerProfile?.billingPhone ?? '';

		const orderInformation = new cybersource.Ptsv2paymentsOrderInformation();
		orderInformation.amountDetails = orderInformationAmountDetails;
		orderInformation.billTo = orderInformationBillTo;

		// create a new ProcessingInformation object
		const processingInformation =
			new cybersource.Ptsv2paymentsProcessingInformation();
		processingInformation.actionList = ['TOKEN_CREATE']; // Actions to create tokens
		processingInformation.actionTokenTypes = ['customer', 'paymentInstrument']; // Token types for the actions

		// create a new TokenInformation object
		const tokenInformationObj = new cybersource.Ptsv2paymentsTokenInformation();

		// create a new PaymentInformation object
		tokenInformationObj.paymentInstrument =
			new cybersource.Ptsv2paymentsTokenInformationPaymentInstrument();

		// Ensure paymentTokenInfo and its properties are not null or undefined
		if (
			paymentTokenInfo?.paymentToken &&
			typeof paymentTokenInfo?.isDefault !== 'undefined'
		) {
			tokenInformationObj.transientTokenJwt = paymentTokenInfo.paymentToken;
			tokenInformationObj.paymentInstrument.default =
				paymentTokenInfo.isDefault; // Set the default payment instrument
		} else {
			// Handle the case where paymentTokenInfo or its properties are null or undefined
			console.error(
				'Error: paymentTokenInfo or its required properties are null or undefined',
			);
			throw new Error(
				'paymentTokenInfo or its required properties are null or undefined',
			);
		}

		// create a new CreatePaymentRequest object
		const createPaymentRequest = new cybersource.CreatePaymentRequest();
		createPaymentRequest.clientReferenceInformation =
			clientReferenceInformation;
		createPaymentRequest.orderInformation = orderInformation;
		createPaymentRequest.processingInformation = processingInformation;
		createPaymentRequest.tokenInformation = tokenInformationObj;

		return new Promise((resolve, reject) => {
			instance.createPayment(
				createPaymentRequest,
				(error: { message?: string }, data: any, _response: any) => {
					if (!error) {
						resolve(data as PaymentTransactionResponse);
					} else {
						reject(
							new Error(
								error.message ||
									'Unknown error occurred in creating customer profile',
							),
						);
					}
				},
			);
		});
	}

	/**
	 * Get a customer profile from the Cybersource API
	 * @param {string} customerId The customer ID to be used for the customer profile
	 * @returns {Promise<CustomerPaymentResponse>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in getting the customer profile
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#token-management_customer_retrieve-a-customer
	 * */
	async getCustomerProfile(
		customerId: string,
	): Promise<CustomerPaymentResponse> {
		const options: any[] = [];
		const instance = new cybersource.CustomerApi(
			this.configObject,
			this.client,
		);
		return new Promise((resolve, reject) => {
			instance.getCustomer(
				customerId,
				options,
				(error: { message?: string }, data: any, _response: any) => {
					if (!error) {
						resolve(data as CustomerPaymentResponse);
					} else {
						reject(
							new Error(
								error.message ||
									'Unknown error occurred in getting customer profile',
							),
						);
					}
				},
			);
		});
	}

	/**
	 * Add a customer payment instrument in the Cybersource API
	 * @param {CustomerProfile} customerProfile The customer profile to be used for the payment instrument
	 * @param {PaymentTokenInfo} paymentTokenInfo The payment token to be used for the payment instrument
	 * @returns {Promise<PaymentTransactionResponse>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in adding the customer payment instrument
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#token-management_customer-payment-instrument_create-a-customer-payment-instrument
	 * */
	async addCustomerPaymentInstrument(
		customerProfile: CustomerProfile,
		paymentTokenInfo: PaymentTokenInfo,
	): Promise<PaymentTransactionResponse> {
		const instance = new cybersource.PaymentsApi(
			this.configObject,
			this.client,
		);

		// create a new PaymentReferenceInformation object used for reconciliation purposes (search)
		const paymentReferenceInformation =
			new cybersource.Ptsv2paymentsClientReferenceInformation();
		paymentReferenceInformation.code = randomUUID();
		paymentReferenceInformation.applicationName = this.applicationName;

		// create a new OrderInformation object
		const orderInformationAmountDetails =
			new cybersource.Ptsv2paymentsOrderInformationAmountDetails();
		orderInformationAmountDetails.totalAmount = '0'; // Zero amount for instrument identifier
		orderInformationAmountDetails.currency = 'USD';

		const orderInformationBillTo =
			new cybersource.Ptsv2paymentsOrderInformationBillTo();
		orderInformationBillTo.firstName = customerProfile.billingFirstName;
		orderInformationBillTo.lastName = customerProfile.billingLastName;
		orderInformationBillTo.address1 = customerProfile.billingAddressLine1;
		orderInformationBillTo.address2 = customerProfile.billingAddressLine2;
		orderInformationBillTo.locality = customerProfile.billingCity;
		orderInformationBillTo.administrativeArea = customerProfile.billingState;
		orderInformationBillTo.postalCode = customerProfile.billingPostalCode;
		orderInformationBillTo.country = customerProfile.billingCountry;
		orderInformationBillTo.email = customerProfile.billingEmail;
		orderInformationBillTo.phoneNumber = customerProfile?.billingPhone ?? '';

		const orderInformation = new cybersource.Ptsv2paymentsOrderInformation();
		orderInformation.amountDetails = orderInformationAmountDetails;
		orderInformation.billTo = orderInformationBillTo;

		// create a new ProcessingInformation object
		const processingInformation =
			new cybersource.Ptsv2paymentsProcessingInformation();
		processingInformation.actionList = ['TOKEN_CREATE']; // Actions to create tokens
		processingInformation.actionTokenTypes = ['paymentInstrument']; // Token types for the actions

		// create a new TokenInformation object
		const tokenInformation = new cybersource.Ptsv2paymentsTokenInformation();

		// create a new PaymentInformation object
		tokenInformation.paymentInstrument =
			new cybersource.Ptsv2paymentsTokenInformationPaymentInstrument();

		// Ensure paymentTokenInfo and its properties are not null or undefined
		if (
			paymentTokenInfo?.paymentToken &&
			typeof paymentTokenInfo?.isDefault !== 'undefined'
		) {
			tokenInformation.transientTokenJwt = paymentTokenInfo.paymentToken;
			tokenInformation.paymentInstrument.default = paymentTokenInfo.isDefault; // Set the default payment instrument
		} else {
			// Handle the case where paymentTokenInfo or its properties are null or undefined
			throw new Error(
				'paymentTokenInfo or its required properties are null or undefined',
			);
		}

		// create a new PaymentInformation object
		const paymentInformation =
			new cybersource.Ptsv2paymentsPaymentInformation();
		const paymentInformationCustomer =
			new cybersource.Ptsv2paymentsPaymentInformationCustomer();
		paymentInformationCustomer.id = customerProfile.customerId;
		paymentInformation.customer = paymentInformationCustomer;

		// create a new CreatePaymentRequest object
		const createPaymentRequest = new cybersource.CreatePaymentRequest();
		createPaymentRequest.clientReferenceInformation =
			paymentReferenceInformation;
		createPaymentRequest.orderInformation = orderInformation;
		createPaymentRequest.processingInformation = processingInformation;
		createPaymentRequest.tokenInformation = tokenInformation;
		createPaymentRequest.paymentInformation = paymentInformation;

		return new Promise((resolve, reject) => {
			instance.createPayment(
				createPaymentRequest,
				(error: { message?: string }, data: any, _response: any) => {
					if (!error) {
						resolve(data as PaymentTransactionResponse);
					} else {
						reject(
							new Error(
								error.message ||
									'Unknown error occurred in adding customer payment instrument',
							),
						);
					}
				},
			);
		});
	}

	/**
	 * Get a customer payment instrument from the Cybersource API
	 * @param {string} customerId The customer ID to be used for the payment instrument
	 * @param {string} paymentInstrumentId The payment instrument ID to be used for the payment instrument
	 * @returns {Promise<CustomerPaymentInstrumentResponse>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in getting the customer payment instrument
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#token-management_customer-payment-instrument_retrieve-a-customer-payment-instrument
	 * */
	async getCustomerPaymentInstrument(
		customerId: string,
		paymentInstrumentId: string,
	): Promise<CustomerPaymentInstrumentResponse> {
		const options: any[] = [];
		const instance = new cybersource.CustomerPaymentInstrumentApi(
			this.configObject,
			this.client,
		);
		return new Promise((resolve, reject) => {
			instance.getCustomerPaymentInstrument(
				customerId,
				paymentInstrumentId,
				options,
				(error: { message?: string }, data: any, _response: any) => {
					if (!error) {
						resolve(data as CustomerPaymentInstrumentResponse);
					} else {
						reject(
							new Error(
								error.message ||
									'Unknown error occurred in getting customer payment instrument',
							),
						);
					}
				},
			);
		});
	}

	/**
	 * Get customer payment instruments from the Cybersource API
	 * @param {string} customerId The customer ID to be used for the payment instruments
	 * @param {number} offset The offset for the payment instruments returned in the response (optional, defaults to 0)
	 * @param {number} limit The limit on the number of payment instruments returned in the response (optional, defaults to 20)
	 * @returns {Promise<CustomerPaymentInstrumentsResponse>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in getting the customer payment instruments
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#token-management_customer-payment-instrument_list-payment-instruments-for-a-customer
	 * */
	async getCustomerPaymentInstruments(
		customerId: string,
		offset?: number,
		limit?: number,
	): Promise<CustomerPaymentInstrumentsResponse> {
		const options: { [key: string]: any } = {};

		options['offset'] = offset; // offset for the payment instruments returned in the response (optional, defaults to 0)
		options['limit'] = limit; // limit on the number of payment instruments returned in the response (optional, defaults to 20)
		const instance = new cybersource.CustomerPaymentInstrumentApi(
			this.configObject,
			this.client,
		);
		return new Promise((resolve, reject) => {
			instance.getCustomerPaymentInstrumentsList(
				customerId,
				options,
				(error: { message?: string }, data: any, _response: any) => {
					if (!error) {
						resolve(data as CustomerPaymentInstrumentsResponse);
					} else {
						reject(
							new Error(
								error.message ||
									'Unknown error occurred in getting customer payment instruments',
							),
						);
					}
				},
			);
		});
	}

	/**
	 * Delete a customer payment instrument from the Cybersource API
	 * @param {string} customerId The customer ID to be used for the payment instrument
	 * @param {string} paymentInstrumentId The payment instrument ID to be used for the payment instrument
	 * @returns {Promise<boolean>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in deleting the customer payment instrument
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#token-management_customer-payment-instrument_delete-a-customer-payment-instrument
	 * */
	async deleteCustomerPaymentInstrument(
		customerId: string,
		paymentInstrumentId: string,
	): Promise<boolean> {
		const options: { [key: string]: any } = {};
		const instance = new cybersource.CustomerPaymentInstrumentApi(
			this.configObject,
			this.client,
		);
		return new Promise((resolve, reject) => {
			instance.deleteCustomerPaymentInstrument(
				customerId,
				paymentInstrumentId,
				options,
				(error: any, _data: any, _response: any) => {
					if (!error) {
						resolve(true);
					} else {
						const errors = error?.response?.body?.errors
							.map((error: { message?: string }) => error.message)
							.join(', ');
						reject(
							new Error(
								errors ||
									'Unknown error occurred in deleting customer payment instrument',
							),
						);
					}
				},
			);
		});
	}

	/**
	 * Set a default customer payment instrument in the Cybersource API
	 * @param {string} customerId The customer ID to be used for the payment instrument
	 * @param {string} paymentInstrumentId The payment instrument ID to be used for the payment instrument
	 * @returns {Promise<CustomerPaymentResponse>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in setting the default customer payment instrument
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#token-management_customer-payment-instrument_update-a-customer-payment-instrument
	 * */
	async setDefaultCustomerPaymentInstrument(
		customerId: string,
		paymentInstrumentId: string,
	): Promise<CustomerPaymentResponse> {
		const options: { [key: string]: any } = {};
		const instance = new cybersource.CustomerApi(
			this.configObject,
			this.client,
		);

		// default payment instrument
		const defaultPaymentInstrument =
			new cybersource.Tmsv2customersDefaultPaymentInstrument();
		defaultPaymentInstrument.id = paymentInstrumentId;

		const customerUpdateRequest = new cybersource.PatchCustomerRequest();
		customerUpdateRequest.defaultPaymentInstrument = defaultPaymentInstrument;

		return new Promise((resolve, reject) => {
			instance.patchCustomer(
				customerId,
				customerUpdateRequest,
				options,
				(error: any, data: any, _response: any) => {
					if (!error) {
						resolve(data as CustomerPaymentResponse);
					} else {
						reject(
							new Error(
								error.message ||
									'Unknown error occurred in setting default customer payment instrument',
							),
						);
					}
				},
			);
		});
	}

	/**
	 * Update a customer payment instrument in the Cybersource API
	 * @param {CustomerProfile} customerProfile The customer profile to be used for the payment instrument
	 * @param {PaymentInstrumentInfo} paymentInstrumentInfo The payment instrument information to be used for the payment instrument
	 * @returns {Promise<CustomerPaymentInstrumentResponse>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in updating the customer payment instrument
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#token-management_customer-payment-instrument_update-a-customer-payment-instrument
	 * */
	async updateCustomerPaymentInstrument(
		customerProfile: CustomerProfile,
		paymentInstrumentInfo: PaymentInstrumentInfo,
	): Promise<CustomerPaymentInstrumentResponse> {
		const options: { [key: string]: any } = {};
		const instance = new cybersource.PaymentInstrumentApi(
			this.configObject,
			this.client,
		);

		const patchCustomerPaymentInstrumentRequest =
			new cybersource.PatchPaymentInstrumentRequest();

		// create a card object
		const card =
			new cybersource.Tmsv2customersEmbeddedDefaultPaymentInstrumentCard();
		card.expirationMonth = paymentInstrumentInfo.cardExpirationMonth;
		card.expirationYear = paymentInstrumentInfo.cardExpirationYear;
		card.type = paymentInstrumentInfo.cardType;
		patchCustomerPaymentInstrumentRequest.card = card;

		// create a billTo object
		const billTo =
			new cybersource.Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo();
		billTo.firstName = customerProfile.billingFirstName;
		billTo.lastName = customerProfile.billingLastName;
		billTo.email = customerProfile.billingEmail;
		billTo.phoneNumber = customerProfile?.billingPhone ?? '';
		billTo.address1 = customerProfile.billingAddressLine1;
		billTo.address2 = customerProfile.billingAddressLine2;
		billTo.locality = customerProfile.billingCity;
		billTo.administrativeArea = customerProfile.billingState;
		billTo.postalCode = customerProfile.billingPostalCode;
		billTo.country = customerProfile.billingCountry;
		patchCustomerPaymentInstrumentRequest.billTo = billTo;

		// create an instrumentIdentifier object
		const paymentInstrumentIdentifier =
			new cybersource.Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier();
		paymentInstrumentIdentifier.id = paymentInstrumentInfo.id;
		patchCustomerPaymentInstrumentRequest.instrumentIdentifier =
			paymentInstrumentIdentifier;

		return new Promise((resolve, reject) => {
			instance.patchPaymentInstrument(
				paymentInstrumentInfo.paymentInstrumentId,
				patchCustomerPaymentInstrumentRequest,
				options,
				(error: any, data: any, _response: any) => {
					if (!error) {
						resolve(data as CustomerPaymentInstrumentResponse);
					} else {
						reject(
							new Error(
								error.message ||
									'Unknown error occurred in updating customer payment instrument',
							),
						);
					}
				},
			);
		});
	}

	/**
	 * Process a payment in the Cybersource API
	 * @param {string} clientReferenceCode The client reference code to be used for the payment
	 * @param {string} paymentInstrumentId The payment instrument ID to be used for the payment
	 * @param {number} amount The amount to be used for the payment
	 * @returns {Promise<PaymentTransactionResponse>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in processing the payment
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#payments_payments_process-a-payment
	 * */
	async createPaymentRequest(
		clientReferenceCode: string,
		paymentInstrumentId: string,
		amount: number,
	): Promise<PaymentTransactionResponse> {
		const instance = new cybersource.PaymentsApi(
			this.configObject,
			this.client,
		);

		// create a new ClientReferenceInformation object used for reconciliation purposes (search)
		const clientReferenceInformation =
			new cybersource.Ptsv2paymentsClientReferenceInformation();
		clientReferenceInformation.code = clientReferenceCode;
		clientReferenceInformation.applicationName = this.applicationName;

		// create a new OrderInformationAmountDetails object
		const orderInformationAmountDetails =
			new cybersource.Ptsv2paymentsOrderInformationAmountDetails();
		orderInformationAmountDetails.totalAmount = amount.toString();
		orderInformationAmountDetails.currency = 'USD';

		const orderInformation = new cybersource.Ptsv2paymentsOrderInformation();
		orderInformation.amountDetails = orderInformationAmountDetails;

		// create a new ProcessingInformation object
		const processingInformation =
			new cybersource.Ptsv2paymentsProcessingInformation();
		processingInformation.capture = true; // Capture the payment

		// create a new PaymentInformation object
		const paymentInformation =
			new cybersource.Ptsv2paymentsPaymentInformation();
		const paymentInfoInstrument =
			new cybersource.Ptsv2paymentsPaymentInformationPaymentInstrument();
		paymentInfoInstrument.id = paymentInstrumentId;
		paymentInformation.paymentInstrument = paymentInfoInstrument;

		// create a new CreatePaymentRequest object
		const createPaymentRequest = new cybersource.CreatePaymentRequest();
		createPaymentRequest.clientReferenceInformation =
			clientReferenceInformation;
		createPaymentRequest.orderInformation = orderInformation;
		createPaymentRequest.processingInformation = processingInformation;
		createPaymentRequest.paymentInformation = paymentInformation;

		return new Promise((resolve, reject) => {
			instance.createPayment(
				createPaymentRequest,
				(error: any, data: any, response: any) => {
					if (!error) {
						resolve(data as PaymentTransactionResponse);
					} else {
						reject({
							code: response.statusCode,
							message: response.body.message,
							timestamp: response.body.submitTimeUtc,
							reason: response.body.reason,
						});
					}
				},
			);
		});
	}

	async processPayment(
		clientReferenceCode: string,
		paymentInstrumentId: string,
		amount: number,
	): Promise<TransactionReceipt> {
		try {
			const paymentResponse = await this.createPaymentRequest(
				clientReferenceCode,
				paymentInstrumentId,
				amount,
			);
			if (paymentResponse?.status === 'AUTHORIZED') {
				return this.createSuccessReceiptForPayment(paymentResponse);
			}
			return this.createFailureReceipt(
				paymentResponse?.processorInformation?.responseCode,
				`${paymentResponse?.status} - ${paymentResponse?.reason}`,
			);
		} catch (error) {
			return this.handlePaymentError(
				error as {
					reason?: string;
					timestamp?: Date;
					code?: string;
					message?: string;
				},
				clientReferenceCode,
			);
		}
	}

	/**
	 * Refund a payment in the Cybersource API
	 * @param {string} transactionId The transaction ID received from the original payment
	 * @param {number} amount The amount to be used for the refund
	 * @returns {Promise<RefundPaymentResponse>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in refunding the payment
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#payments_refund_refund-a-capture
	 * */
	async refundPayment(
		transactionId: string,
		amount: number,
	): Promise<RefundPaymentResponse> {
		const instance = new cybersource.RefundApi(this.configObject, this.client);

		// create a new OrderInformationAmountDetails object
		const orderInformationAmountDetails =
			new cybersource.Ptsv2paymentsOrderInformationAmountDetails();
		orderInformationAmountDetails.totalAmount = amount.toString();
		orderInformationAmountDetails.currency = 'USD';

		const orderInformation = new cybersource.Ptsv2paymentsOrderInformation();
		orderInformation.amountDetails = orderInformationAmountDetails;

		// create a new ProcessingInformation object
		const processingInformation =
			new cybersource.Ptsv2paymentsProcessingInformation();
		processingInformation.capture = true; // Capture the payment

		// create a new RefundCaptureRequest object
		const refundCaptureRequest = new cybersource.RefundCaptureRequest();
		refundCaptureRequest.reason = 'Refund';
		refundCaptureRequest.orderInformation = orderInformation;
		refundCaptureRequest.processingInformation = processingInformation;

		return new Promise((resolve, reject) => {
			instance.refundCapture(
				refundCaptureRequest,
				transactionId,
				(error: any, data: any, _response: any) => {
					if (!error) {
						resolve(data as RefundPaymentResponse);
					} else {
						reject(
							new Error(
								error.message || 'Unknown error occurred in refunding payment',
							),
						);
					}
				},
			);
		});
	}

	async processRefund(
		transactionId: string,
		amount: number,
		referenceId: string,
	): Promise<TransactionReceipt> {
		try {
			const refundResponse = await this.refundPayment(transactionId, amount);
			if (
				refundResponse?.status === 'AUTHORIZED' ||
				refundResponse?.status === 'PENDING'
			) {
				return this.createSuccessReceiptForRefund(refundResponse);
			}
			return this.createFailureReceipt(
				refundResponse?.processorInformation?.responseCode,
				'Refund failed to process',
			);
		} catch (error) {
			return this.handlePaymentError(
				error as {
					reason?: string;
					timestamp?: Date;
					code?: string;
					message?: string;
				},
				referenceId,
			);
		}
	}

	/**
	 * Void a payment in the Cybersource API
	 * @param {string} clientReferenceCode The client reference code used for the original payment
	 * @param {string} transactionId The transaction ID received from the original payment
	 * @returns {Promise<PaymentTransactionResponse>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in voiding the payment
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#payments_void_void-a-capture
	 * */
	async voidPayment(
		clientReferenceCode: string,
		transactionId: string,
	): Promise<PaymentTransactionResponse> {
		const instance = new cybersource.VoidApi(this.configObject, this.client);

		// create a new ClientReferenceInformation object used for reconciliation purposes (search)
		const clientReferenceInformation =
			new cybersource.Ptsv2paymentsClientReferenceInformation();
		clientReferenceInformation.code = clientReferenceCode;
		clientReferenceInformation.applicationName = this.applicationName;

		// create a new VoidCaptureRequest object
		const voidCaptureRequest = new cybersource.VoidCaptureRequest();
		voidCaptureRequest.clientReferenceInformation = clientReferenceInformation;

		return new Promise((resolve, reject) => {
			instance.voidCapture(
				voidCaptureRequest,
				transactionId,
				(
					error: {
						reason?: string;
						timestamp?: Date;
						code?: string;
						message?: string;
					},
					data: any,
					_response: any,
				) => {
					if (!error) {
						resolve(data as PaymentTransactionResponse);
					} else {
						reject(
							new Error(
								error.message || 'Unknown error occurred in voiding payment',
							),
						);
					}
				},
			);
		});
	}

	/**
	 * Search for transactions in the Cybersource API
	 * @param {string} clientReferenceCode The client reference code to be used for the search
	 * @returns {Promise<TransactionSearchResponse>} The response from the Cybersource API
	 * @throws {Error} If an error occurs in searching for transactions
	 * full details: https://developer.cybersource.com/api-reference-assets/index.html#transaction-search_search-transactions_create-a-search-request
	 * */
	private async searchTransactions(
		clientReferenceCode: string,
	): Promise<TransactionSearchResponse> {
		const instance = new cybersource.SearchTransactionsApi(
			this.configObject,
			this.client,
		);

		const searchRequest = new cybersource.CreateSearchRequest();
		searchRequest.query = `clientReferenceInformation.code:${clientReferenceCode}`;
		searchRequest.offset = 0;
		searchRequest.limit = 2000;
		searchRequest.sort = 'id:asc,submitTimeUtc:desc';
		searchRequest.save = false;

		return new Promise((resolve, reject) => {
			instance.createSearch(searchRequest, (error: any, data: any, response: any) => {
				if (!error) {
					resolve(data as TransactionSearchResponse);
				} else {
					reject(new Error(response));
				}
			});
		});
	}

	async getSuccessOrLatestFailedTransactionsByReferenceId(
		referenceId: string,
	): Promise<TransactionReceipt | null> {
		try {
			const searchResult = await this.searchTransactions(referenceId);
			const transactions = searchResult?._embedded?.transactionSummaries;
			if (!transactions) {
				return null;
			}
			const successTransaction = transactions.find(
				(transaction) =>
					transaction.applicationInformation.reasonCode === '100',
			);
			if (successTransaction) {
				return {
					isSuccess: true,
					vendor: 'Cybersource',
					completedAt: new Date(successTransaction.submitTimeUtc),
					amount: Number(
						successTransaction.orderInformation.amountDetails?.totalAmount,
					),
					transactionId: successTransaction.id,
					reconciliationId:
						successTransaction.applicationInformation.applications.filter(
							(rec) => rec.name === 'ics_bill',
						)[0]?.reconciliationId ?? '',
				};
			} else {
				const latestFailedTransaction = transactions[transactions.length - 1];
				if (!latestFailedTransaction) {
					return null;
				}
				// decode rFlag
				const rFlag = latestFailedTransaction?.applicationInformation?.rFlag;
				const decodeRiskFlag = this.DecodeRiskFlag(rFlag ?? '');
				return {
					isSuccess: false,
					errorOccurredAt: new Date(latestFailedTransaction.submitTimeUtc),
					errorCode: `${latestFailedTransaction.applicationInformation?.reasonCode}`, // most likely 400
					errorMessage: decodeRiskFlag,
				} as TransactionReceipt;
			}
		} catch (error) {
			return this.createErrorReceipt(error as {
        timestamp?: Date;
        code?: string;
        message?: string;
      });
		}
	}

	private DecodeRiskFlag(rFlag: string) {
		const rFlagCode = rFlag.substring(0, 1);
		const rFlagMessage = rFlag.substring(1);
		switch (rFlagCode) {
			case 'A':
				return 'Accept';
			case 'D':
				return 'Declined - ' + rFlagMessage;
			case 'R':
				return 'Review';
			default:
				return `Invalid risk flag ${rFlagCode} - ${rFlagMessage}`;
		}
	}

	private createSuccessReceiptForPayment(
		paymentResponse: PaymentTransactionResponse,
	): TransactionReceipt {
		return {
			isSuccess: true,
			vendor: 'Cybersource',
			completedAt: new Date(paymentResponse.submitTimeUtc),
			amount: Number(
				paymentResponse.orderInformation.amountDetails.totalAmount,
			),
			transactionId: paymentResponse.id,
			reconciliationId: paymentResponse.reconciliationId,
		};
	}

	private createSuccessReceiptForRefund(
		refundResponse: RefundPaymentResponse,
	): TransactionReceipt {
		return {
			isSuccess: true,
			vendor: 'Cybersource',
			completedAt: new Date(refundResponse.submitTimeUtc),
			amount: Number(refundResponse.refundAmountDetails.refundAmount),
			transactionId: refundResponse.id,
			reconciliationId: refundResponse.reconciliationId,
		};
	}

	private createFailureReceipt(
		code?: string,
		message?: string,
	): TransactionReceipt {
		return {
			isSuccess: false,
			errorOccurredAt: new Date(),
			errorCode: code ?? '400',
			errorMessage: message ?? 'Unknown error occurred in processing payment',
		};
	}

	private async handlePaymentError(
		error: {
			reason?: string;
			timestamp?: Date;
			code?: string;
			message?: string;
		},
		clientReferenceCode: string,
	): Promise<TransactionReceipt> {
		if (error?.reason === 'DUPLICATE_REQUEST') {
			return await this.handleDuplicateRequest(clientReferenceCode);
		}
		return this.createErrorReceipt(error);
	}

	private async handleDuplicateRequest(
		clientReferenceCode: string,
	): Promise<TransactionReceipt> {
		const searchResult =
			await this.getSuccessOrLatestFailedTransactionsByReferenceId(
				clientReferenceCode,
			);
		return searchResult?.isSuccess ? searchResult : this.createFailureReceipt();
	}

	private createErrorReceipt(error: {
		timestamp?: Date;
		code?: string;
		message?: string;
	}): TransactionReceipt {
		return {
			isSuccess: false,
			errorOccurredAt: error.timestamp ?? new Date(),
			errorCode: error.code ?? '400',
			errorMessage:
				error.message ?? 'Unknown error occurred in processing payment',
		};
	}

	async createPlan(plan: PlanCreation): Promise<PlanCreationResponse> {
		console.log('createPlan method called with plan:', plan);
		throw new Error('Method not implemented.');
	}

	async listOfPlans(): Promise<PlansListResponse> {
		throw new Error('Method not implemented.');
	}

	async getPlan(planId: string): Promise<PlanResponse> {
		console.log('getPlan method called with planId:', planId);
		throw new Error('Method not implemented.');
	}

	async createSubscription(
		subscription: Subscription,
	): Promise<SubscriptionResponse> {
		console.log(
			'createSubscription method called with subscription:',
			subscription,
		);
		throw new Error('Method not implemented.');
	}

	async updatePlanForSubscription(
		subscriptionId: string,
		planId: string,
	): Promise<SubscriptionResponse> {
		console.log(
			'updatePlanForSubscription method called with subscriptionId:',
			subscriptionId,
			'and planId:',
			planId,
		);
		throw new Error('Method not implemented.');
	}

	async listOfSubscriptions(): Promise<SubscriptionsListResponse> {
		throw new Error('Method not implemented.');
	}

	async suspendSubscription(
		subscriptionId: string,
	): Promise<SuspendSubscriptionResponse> {
		console.log(
			'suspendSubscription method called with subscriptionId:',
			subscriptionId,
		);
		throw new Error('Method not implemented.');
	}
}
