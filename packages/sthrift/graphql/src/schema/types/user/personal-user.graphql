type PersonalUser implements MongoBase {
  userType: String
  isBlocked: Boolean
  account: PersonalUserAccount
  hasCompletedOnboarding: Boolean
  role: PersonalUserRole
  id: ObjectID!
  schemaVersion: String
  createdAt: DateTime
  updatedAt: DateTime
}

type PersonalUserAccount {
  accountType: String
  email: String
  username: String
  profile: PersonalUserAccountProfile
}

type PersonalUserAccountProfile {
  firstName: String
  lastName: String
  location: PersonalUserAccountProfileLocation
  billing: PersonalUserAccountProfileBilling
}

type PersonalUserAccountProfileLocation {
  address1: String
  address2: String
  city: String
  state: String
  country: String
  zipCode: String
}

type PersonalUserAccountProfileBilling {
  cybersourceCustomerId: String
  subscription: PersonalUserAccountProfileBillingSubscription
  transactions: [PersonalUserAccountProfileBillingTransaction]
}

type PersonalUserAccountProfileBillingSubscription {
  subscriptionId: String
  planCode: String
  status: String
  startDate: DateTime
}

type PersonalUserAccountProfileBillingTransaction {
  transactionId: String
  amount: Float
  referenceId: String
  status: String
  completedAt: DateTime
  errorMessage: String
}

input PersonalUserUpdateInput {
  id: ObjectID!
  isBlocked: Boolean
  account: PersonalUserAccountUpdateInput
}

input PersonalUserAccountUpdateInput {
  accountType: String
  username: String
  profile: PersonalUserAccountProfileUpdateInput
}

input PersonalUserAccountProfileUpdateInput {
  firstName: String
  lastName: String
  location: PersonalUserAccountProfileLocationUpdateInput
}

input PersonalUserAccountProfileLocationUpdateInput {
  address1: String
  address2: String
  city: String
  state: String
  country: String
  zipCode: String
}

# Payment related input/output types
input PaymentAmountDetails {
  totalAmount: Float!
  currency: String!
}

input PaymentBillTo {
  firstName: String!
  lastName: String!
  address1: String!
  address2: String
  city: String!
  state: String!
  postalCode: String!
  country: String!
  phoneNumber: String
  email: String
}

input PaymentCard {
  number: String!
  expirationMonth: String!
  expirationYear: String!
  securityCode: String!
}

input PaymentOrderInformation {
  amountDetails: PaymentAmountDetails!
  billTo: PaymentBillTo!
}

input PaymentCardInformation {
  card: PaymentCard!
}

input PaymentRequest {
  userId: ObjectID!
  orderInformation: PaymentOrderInformation!
  paymentInformation: PaymentCardInformation!
}

type PaymentErrorInformation {
  reason: String
  message: String
}

type PaymentResponseAmountDetails {
  totalAmount: String
  currency: String
}

type PaymentResponseOrderInformation {
  amountDetails: PaymentResponseAmountDetails
}

type PaymentResponse {
  id: String
  status: String!
  success: Boolean
  message: String
  errorInformation: PaymentErrorInformation
  orderInformation: PaymentResponseOrderInformation
}

input RefundOrderInformation {
  amountDetails: PaymentAmountDetails!
}

input RefundRequest {
  userId: ObjectID!
  transactionId: String!
  amount: Float
  orderInformation: RefundOrderInformation!
}

type RefundResponse {
  id: String
  status: String!
  success: Boolean
  message: String
  errorInformation: PaymentErrorInformation
  orderInformation: PaymentResponseOrderInformation
}

type PersonalUserMutationResult implements MutationResult {
  status: MutationStatus!
  personalUser: PersonalUser
}

extend type Query {
  # Personal User queries
  personalUserById(id: ObjectID!): PersonalUser
  currentPersonalUserAndCreateIfNotExists: PersonalUser!
}

extend type Mutation {
  # Personal User mutations
  personalUserUpdate(input: PersonalUserUpdateInput!): PersonalUserMutationResult!

  # Payment mutations
  processPayment(request: PaymentRequest!): PaymentResponse!
  refundPayment(request: RefundRequest!): RefundResponse!
}
