#graphql
"""
GraphQL schema for Personal Users
"""
enum PaymentState {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}

type PersonalUser implements MongoBase {
  userType: String!
  isBlocked: Boolean!
  account: PersonalUserAccount!

  id: ObjectID!
  schemaVersion: String
  createdAt: DateTime
  updatedAt: DateTime
}

type PersonalUserAccount {
  accountType: String!
  email: String!
  username: String!
  profile: PersonalUserAccountProfile!
}

type PersonalUserAccountProfile {
  firstName: String!
  lastName: String!
  location: PersonalUserAccountProfileLocation!
  billing: PersonalUserAccountProfileBilling
}

type PersonalUserAccountProfileLocation {
  address1: String!
  address2: String
  city: String!
  state: String!
  country: String!
  zipCode: String!
}

type PersonalUserAccountProfileBilling {
  subscriptionId: String
  cybersourceCustomerId: String
  lastTransactionId: String
  paymentState: PaymentState
  lastPaymentAmount: Float
}

input PersonalUserCreateInput {
  userType: String!
  account: PersonalUserAccountInput!
}

input PersonalUserAccountInput {
  accountType: String!
  email: String!
  username: String!
  profile: PersonalUserAccountProfileInput!
}

input PersonalUserAccountProfileInput {
  firstName: String!
  lastName: String!
  location: PersonalUserAccountProfileLocationInput!
  billing: PersonalUserAccountProfileBillingInput
}

input PersonalUserAccountProfileLocationInput {
  address1: String!
  address2: String
  city: String!
  state: String!
  country: String!
  zipCode: String!
}

input PersonalUserAccountProfileBillingInput {
  subscriptionId: String
  cybersourceCustomerId: String
  lastTransactionId: String
  paymentState: PaymentState
  lastPaymentAmount: Float
}

input PersonalUserUpdateInput {
  userType: String
  isBlocked: Boolean
  account: PersonalUserAccountUpdateInput
}

input PersonalUserAccountUpdateInput {
  accountType: String
  email: String
  username: String
  profile: PersonalUserAccountProfileUpdateInput
}

input PersonalUserAccountProfileUpdateInput {
  firstName: String
  lastName: String
  location: PersonalUserAccountProfileLocationUpdateInput
  billing: PersonalUserAccountProfileBillingUpdateInput
}

input PersonalUserAccountProfileLocationUpdateInput {
  address1: String
  address2: String
  city: String
  state: String
  country: String
  zipCode: String
}

input PersonalUserAccountProfileBillingUpdateInput {
  subscriptionId: String
  cybersourceCustomerId: String
  lastTransactionId: String
  paymentState: PaymentState
  lastPaymentAmount: Float
}

extend type Query {
  # Personal User queries
  personalUserById(id: ObjectID!): PersonalUser
  # currentEndUserAndCreateIfNotExists: PersonalUser!
}

# Payment related input/output types
input PaymentAmountDetails {
  totalAmount: Float!
  currency: String!
}

input PaymentBillTo {
  firstName: String!
  lastName: String!
  address1: String!
  address2: String
  city: String!
  state: String!
  postalCode: String!
  country: String!
  phoneNumber: String
  email: String
}

input PaymentCard {
  number: String!
  expirationMonth: String!
  expirationYear: String!
  securityCode: String!
}

input PaymentOrderInformation {
  amountDetails: PaymentAmountDetails!
  billTo: PaymentBillTo!
}

input PaymentCardInformation {
  card: PaymentCard!
}

input PaymentRequest {
  userId: ObjectID!
  amount: Float
  source: String
  description: String
  orderInformation: PaymentOrderInformation!
  paymentInformation: PaymentCardInformation!
}

type PaymentErrorInformation {
  reason: String
  message: String
}

type PaymentResponseAmountDetails {
  totalAmount: String
  currency: String
}

type PaymentResponseOrderInformation {
  amountDetails: PaymentResponseAmountDetails
}

type PaymentResponse {
  id: String
  status: String!
  success: Boolean
  message: String
  errorInformation: PaymentErrorInformation
  orderInformation: PaymentResponseOrderInformation
}

input RefundOrderInformation {
  amountDetails: PaymentAmountDetails!
}

input RefundRequest {
  userId: ObjectID!
  transactionId: String!
  orderInformation: RefundOrderInformation!
}

type RefundResponse {
  id: String
  status: String!
  errorInformation: PaymentErrorInformation
  orderInformation: PaymentResponseOrderInformation
}

extend type Mutation {
  # Personal User mutations
  personalUserUpdate(id: ObjectID!, input: PersonalUserUpdateInput!): PersonalUser!
  
  # Payment mutations
  processPayment(request: PaymentRequest!): PaymentResponse!
  refundPayment(request: RefundRequest!): RefundResponse!
}
