"use strict";(globalThis.webpackChunk_sthrift_docs=globalThis.webpackChunk_sthrift_docs||[]).push([[142],{5392(e,n,i){i.d(n,{R:()=>o,x:()=>d});var s=i(9081);const t={},l=s.createContext(t);function o(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(l.Provider,{value:n},e.children)}},7574(e,n,i){i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>d,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"decisions/docusaurus-azure-pipeline-stages","title":"Split Docusaurus Azure Pipeline into Separate Build and Deploy Stages","description":"Split Docusaurus Azure Pipeline into separate build and deploy stages to prevent unwanted deployments from PRs.","source":"@site/docs/decisions/0018-docusaurus-azure-pipeline-stages.md","sourceDirName":"decisions","slug":"/decisions/docusaurus-azure-pipeline-stages","permalink":"/docs/decisions/docusaurus-azure-pipeline-stages","draft":false,"unlisted":false,"editUrl":"https://github.com/simnova/sharethrift/tree/main/packages/docs/docs/decisions/0018-docusaurus-azure-pipeline-stages.md","tags":[],"version":"current","sidebarPosition":18,"frontMatter":{"sidebar_position":18,"sidebar_label":"0018 Docusaurus Azure Pipeline Stages","description":"Split Docusaurus Azure Pipeline into separate build and deploy stages to prevent unwanted deployments from PRs.","status":"accepted","date":"2025-01-08T00:00:00.000Z","deciders":"development team","consulted":null,"informed":"team"},"sidebar":"docsSidebar","previous":{"title":"0017 Chrome Content Overrides","permalink":"/docs/decisions/chrome-content-overrides"},"next":{"title":"0022 Existing Azure Upload","permalink":"/docs/decisions/existing-azure-upload"}}');var t=i(8525),l=i(5392);const o={sidebar_position:18,sidebar_label:"0018 Docusaurus Azure Pipeline Stages",description:"Split Docusaurus Azure Pipeline into separate build and deploy stages to prevent unwanted deployments from PRs.",status:"accepted",date:new Date("2025-01-08T00:00:00.000Z"),deciders:"development team",consulted:null,informed:"team"},d="Split Docusaurus Azure Pipeline into Separate Build and Deploy Stages",r={},a=[{value:"Context and Problem Statement",id:"context-and-problem-statement",level:2},{value:"Decision Drivers",id:"decision-drivers",level:2},{value:"Considered Options",id:"considered-options",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Consequences",id:"consequences",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Build Stage",id:"build-stage",level:3},{value:"Deploy Stage",id:"deploy-stage",level:3},{value:"Key Technical Changes",id:"key-technical-changes",level:3},{value:"Validation",id:"validation",level:2},{value:"More Information",id:"more-information",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"split-docusaurus-azure-pipeline-into-separate-build-and-deploy-stages",children:"Split Docusaurus Azure Pipeline into Separate Build and Deploy Stages"})}),"\n",(0,t.jsx)(n.h2,{id:"context-and-problem-statement",children:"Context and Problem Statement"}),"\n",(0,t.jsxs)(n.p,{children:["The Sharethrift project uses Docusaurus for documentation hosting via GitHub Pages, with Azure Pipelines handling the CI/CD process. The previous single-stage pipeline configuration (",(0,t.jsx)(n.code,{children:"docusaurus/azure-pipelines.yml"}),") was executing both build and deployment operations on every commit, including pull requests. This resulted in unwanted deployments of documentation changes that hadn't been merged to the ",(0,t.jsx)(n.code,{children:"main"})," branch yet, which violates CI/CD best practices and could potentially deploy incomplete or unreviewed documentation."]}),"\n",(0,t.jsxs)(n.p,{children:["We needed a solution that would validate documentation builds on every PR while only deploying documentation after successful merge to ",(0,t.jsx)(n.code,{children:"main"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"decision-drivers",children:"Decision Drivers"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Controlled Deployments"}),": Documentation should only be deployed after code review and merge to main branch"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build Validation"}),": Every PR should validate that documentation builds successfully"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CI/CD Best Practices"}),": Separate build validation from deployment concerns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Artifact Efficiency"}),": Avoid redundant builds between stages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistency"}),": Align with existing multi-stage patterns used by API package pipeline"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"considered-options",children:"Considered Options"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Option 1"}),": Keep single-stage pipeline with conditional deployment logic"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Option 2"}),": Split into multi-stage pipeline with build and deploy stages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Option 3"}),": Use separate pipeline files for build vs deploy"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"decision-outcome",children:"Decision Outcome"}),"\n",(0,t.jsxs)(n.p,{children:["Chosen option: ",(0,t.jsx)(n.strong,{children:"Split into multi-stage pipeline with build and deploy stages"}),", because it provides clean separation of concerns, follows Azure Pipelines best practices, and aligns with the existing multi-stage approach used by the API package pipeline."]}),"\n",(0,t.jsx)(n.h3,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Good"}),": PRs now only trigger builds, never deployments, preventing unwanted documentation updates"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Good"}),": Build validation occurs on every PR commit, catching documentation build issues early"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Good"}),": Deployments are controlled and only occur after successful merge to main"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Good"}),": Efficient artifact handling eliminates redundant builds between stages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Good"}),": Consistent patterns across project pipelines improve maintainability"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Neutral"}),": Slightly more complex pipeline configuration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bad"}),": None identified"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,t.jsx)(n.h3,{id:"build-stage",children:"Build Stage"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Triggers"}),": Runs on both PR commits and main branch pushes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"npm ci"})," to install dependencies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"npm run build"})," to build documentation"]}),"\n",(0,t.jsx)(n.li,{children:"Publishes build artifacts for deployment stage"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Validates that documentation builds successfully before allowing merge"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"deploy-stage",children:"Deploy Stage"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Triggers"}),": Only runs on main branch pushes (includes condition: ",(0,t.jsx)(n.code,{children:"and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dependencies"}),": Requires successful build stage completion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Downloads build artifacts from build stage"}),"\n",(0,t.jsx)(n.li,{children:"Restores artifacts to correct build directory"}),"\n",(0,t.jsxs)(n.li,{children:["Runs ",(0,t.jsx)(n.code,{children:"npm run deploy --skip-build"})," to deploy to GitHub Pages"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Deploys documentation only after successful merge to main"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"key-technical-changes",children:"Key Technical Changes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Converted from single job to multi-stage pipeline with ",(0,t.jsx)(n.code,{children:"stages:"})," configuration"]}),"\n",(0,t.jsxs)(n.li,{children:["Added ",(0,t.jsx)(n.code,{children:"PublishBuildArtifacts@1"})," task to build stage for artifact sharing"]}),"\n",(0,t.jsxs)(n.li,{children:["Added ",(0,t.jsx)(n.code,{children:"DownloadBuildArtifacts@1"})," and artifact restoration logic to deploy stage"]}),"\n",(0,t.jsxs)(n.li,{children:["Used ",(0,t.jsx)(n.code,{children:"--skip-build"})," flag with Docusaurus deploy command to use pre-built artifacts"]}),"\n",(0,t.jsxs)(n.li,{children:["Applied conditional deployment using ",(0,t.jsx)(n.code,{children:"condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"validation",children:"Validation"}),"\n",(0,t.jsx)(n.p,{children:"Implementation can be validated by:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Confirming that PR commits trigger only the build stage and do not deploy"}),"\n",(0,t.jsx)(n.li,{children:"Verifying that main branch pushes trigger both build and deploy stages"}),"\n",(0,t.jsx)(n.li,{children:"Ensuring that failed builds prevent deployment stage execution"}),"\n",(0,t.jsx)(n.li,{children:"Testing that build artifacts are correctly shared between stages"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"more-information",children:"More Information"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Based on changes from ShareThrift project PR #131"}),"\n",(0,t.jsx)(n.li,{children:"Follows the same multi-stage pattern established in the API package pipeline"}),"\n",(0,t.jsx)(n.li,{children:"Uses Azure Pipelines artifact publishing/downloading for efficient stage communication"}),"\n",(0,t.jsxs)(n.li,{children:["Leverages Docusaurus ",(0,t.jsx)(n.code,{children:"--skip-build"})," flag for deployment optimization"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);