parameters:
- name: vmImageName
  displayName: 'VM Image - ubuntu-latest'
  type: string
- name: pnpm_config_cache
  displayName: 'PNPM Config Cache'
  type: string
- name: isPnpmCacheAvailable
  displayName: 'Flag to indicate if PNPM cache is available'
  type: string
- name: disableSonarCloudTasks
  displayName: 'Flag to disable SonarCloud tasks'
  type: string
- name: SONAR_USER_HOME
  displayName: 'SonarCloud User Home'
  type: string
- name: SonarCloud
  displayName: 'SonarCloud'
  type: string
- name: SonarCloud_organization
  displayName: 'SonarCloud Organization'
  type: string
- name: SonarCloud_scannerMode
  displayName: 'SonarCloud Scanner Mode'
  type: string
- name: SonarCloud_configMode
  displayName: 'SonarCloud Config Mode'
  type: string
- name: SonarCloud_cliProjectKey
  displayName: 'SonarCloud CLI Project Key'
  type: string
- name: SonarCloud_cliProjectName
  displayName: 'SonarCloud CLI Project Name'
  type: string
- name: buildEnvSettings
  displayName: 'ENV Settings to be injected during npm build'
  type: object
  default: {}

stages:
- stage: Build
  displayName: Build stage
  jobs:
  - job: Build
    displayName: Build
    pool:
      vmImage: ${{parameters.vmImageName}}
    variables:
      - name: PLAYWRIGHT_BROWSERS_PATH
        value: /home/vsts/.cache/ms-playwright
    steps:
    - checkout: self
      fetchDepth: 0 # Fetch all history for all branches and tags necessary for sonar cloud analysis
      # SonarCloud documentation https://docs.sonarsource.com/sonarqube-server/latest/analyzing-source-code/scm-integration/#:~:text=A%20full%20clone%20is%20required%20for%20this%20integration%20to%20be%20able%20to%20collect%20the%20required%20blame%20information%20(see%20Known%20Issues).%20If%20a%20shallow%20clone%20is%20detected%2C%20a%20warning%20will%20be%20logged%20and%20no%20attempt%20will%20be%20made%20to%20retrieve%20blame%20information.

    # Ensure the correct version of Node is installed.
    - task: NodeTool@0
      displayName: 'Install: Node.js - LTS'
      inputs:
        versionSpec: '22.20.0'

    # Cache Azure Functions Core Tools
    - task: Cache@2
      displayName: 'Azure Functions: Restore Core Tools Cache'
      inputs:
        key: 'func-tools | "$(Agent.OS)" | "4.2.1"'
        restoreKeys: |
          func-tools | "$(Agent.OS)"
        path: '/opt/hostedtoolcache/func'
        cacheHitVar: FUNC_TOOLS_CACHE_HIT

    # Ensure the correct version of function tools are installed.
    - task: FuncToolsInstaller@0
      displayName: 'Install: func tools - 4.2.1'
      condition: and(ne(variables.FUNC_TOOLS_CACHE_HIT, 'true'), ne(variables.FUNC_TOOLS_CACHE_HIT, 'inexact'))
      inputs:
        version: '4.2.1'
        
    # Cache PNPM store to speed up build process.
    - task: Cache@2
      displayName: 'PNPM: Restore Cache'
      condition: and(succeeded(), eq(${{parameters.isPnpmCacheAvailable}}, True))
      inputs:
        key: 'pnpm | "$(Agent.OS)" | $(Build.SourcesDirectory)/pnpm-lock.yaml'
        restoreKeys: |
            pnpm | "$(Agent.OS)"
        path: ${{parameters.pnpm_config_cache}}

    # Install PNPM
    - task: Bash@3
      displayName: 'Install: PNPM'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "Installing PNPM..."
          npm install --global corepack@latest
          corepack enable
          corepack prepare pnpm@latest-10 --activate
          pnpm config set store-dir ${{parameters.pnpm_config_cache}}
          pnpm --version
        workingDirectory: ''

    # Install dependencies
    - task: Bash@3
      displayName: 'PNPM: Install dependencies'
      condition: and(succeeded(), eq(${{parameters.isPnpmCacheAvailable}}, False))
      inputs:
        targetType: 'inline'
        script: |
          export NODE_OPTIONS=--max_old_space_size=16384
          pnpm install
        workingDirectory: ''

    - task: Bash@3
      displayName: 'PNPM: Install dependencies using cache'
      condition: and(succeeded(), eq(${{parameters.isPnpmCacheAvailable}}, True))
      inputs:
        targetType: 'inline'
        script: |
          export NODE_OPTIONS=--max_old_space_size=16384
          pnpm install --frozen-lockfile
        workingDirectory: ''

    # Set PLAYWRIGHT_VERSION variable for cache key
    - task: Bash@3
      displayName: 'Detect Playwright version for cache key'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          version=$(pnpm exec playwright --version | awk '{print $2}')
          echo "Detected Playwright version: $version"
          echo "##vso[task.setvariable variable=PLAYWRIGHT_VERSION]$version"
        workingDirectory: ''

        # Playwright: Restore browsers cache
    - task: Cache@2
      displayName: 'Playwright: Restore browsers cache'
      inputs:
        key: playwright | "$(Agent.OS)" | ubuntu-latest | node-22 | "$(PLAYWRIGHT_VERSION)"
        path: '$(PLAYWRIGHT_BROWSERS_PATH)'
        cacheHitVar: PW_CACHE_HIT

    # Playwright: Install browsers if needed
    - task: Bash@3
      displayName: 'Playwright: Install browsers if needed'
      condition: and(ne(variables.PW_CACHE_HIT, 'true'), ne(variables.PW_CACHE_HIT, 'inexact'))
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "PW_CACHE_HIT=${PW_CACHE_HIT:-unset}"
          echo "Installing Playwright browsers into: $(PLAYWRIGHT_BROWSERS_PATH)"
          mkdir -p "$(PLAYWRIGHT_BROWSERS_PATH)"
          pnpm exec playwright install --with-deps
      env:
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)

    # Playwright: Ensure browsers are available for packages that need them
    - task: Bash@3
      displayName: 'Playwright: Verify browser installation'
      condition: always()
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "Verifying Playwright browser installation..."
          echo "PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)"

          # Check if browsers are installed
          if [ ! -d "$(PLAYWRIGHT_BROWSERS_PATH)" ] || [ -z "$(ls -A "$(PLAYWRIGHT_BROWSERS_PATH)" 2>/dev/null || echo '')" ]; then
            echo "Browsers not found in cache, installing them..."
            mkdir -p "$(PLAYWRIGHT_BROWSERS_PATH)"
            pnpm exec playwright install --with-deps
          fi

          # Explicitly ensure chromium headless shell is available (used by Vitest browser provider)
          if ! find "$(PLAYWRIGHT_BROWSERS_PATH)" -maxdepth 2 -type d -name 'chromium_headless_shell-*' | grep -q chromium_headless_shell; then
            echo "chromium_headless_shell not found; reinstalling browsers to fetch it..."
            pnpm exec playwright install --with-deps
          fi

          echo "Installed browsers:"
          ls -la "$(PLAYWRIGHT_BROWSERS_PATH)" || true

          # Make sure browser binaries are executable
          find "$(PLAYWRIGHT_BROWSERS_PATH)" -type f -name "*chrome*" -exec chmod +x {} \; 2>/dev/null || true
          find "$(PLAYWRIGHT_BROWSERS_PATH)" -type f -name "headless_shell" -exec chmod +x {} \; 2>/dev/null || true
      env:
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)

    # Cache Turbo to speed up build process
    - task: Cache@2
      displayName: 'Cache Turborepo artifacts'
      inputs:
        key: 'turbo-cache-v3 | "$(Agent.OS)" | $(Build.SourcesDirectory)/turbo.json | $(Build.SourcesDirectory)/pnpm-lock.yaml | $(Build.SourcesDirectory)/package.json'
        restoreKeys: |
          turbo-cache-v3 | "$(Agent.OS)" | $(Build.SourcesDirectory)/turbo.json | $(Build.SourcesDirectory)/pnpm-lock.yaml
          turbo-cache-v3 | "$(Agent.OS)" | $(Build.SourcesDirectory)/turbo.json
          turbo-cache-v3 | "$(Agent.OS)"
          turbo-cache-v3
        path: '.turbo/cache'
        cacheHitVar: 'TURBO_CACHE_HIT'

    # Detect affected package types
    - task: Bash@3
      displayName: 'Detect affected package types'
      name: BuildJob
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          node ./build-pipeline/scripts/detect-changes.cjs
      env:
        Build_Reason: $(Build.Reason)
        System_PullRequest_TargetBranch: $(System.PullRequest.TargetBranch)
        Build_SourceBranch: $(Build.SourceBranch)

    # Build and run tests on affected packages using Turbo's --affected flag
    - task: Bash@3
      displayName: 'Turbo: Build and test affected packages'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "Open file limit (ulimit -n): $(ulimit -n)"
          export NODE_OPTIONS=--max_old_space_size=16384
          export PLAYWRIGHT_BROWSERS_PATH="$(PLAYWRIGHT_BROWSERS_PATH)"

          # Show Turbo cache status
          echo "Turbo cache status: ${TURBO_CACHE_HIT:-cache miss}"
          if [ -d ".turbo/cache" ]; then
            echo "Turbo cache directory exists with $(ls -1 .turbo/cache | wc -l) entries"
          fi

          # Audit pnpm packages for vulnerabilities
          echo "Running pnpm audit for vulnerabilities..."
          pnpm audit --audit-level=high --prod

          # Use Turbo's built-in --affected flag for accurate change detection
          # Split coverage collection: Node tests first, then Storybook tests separately
          # to reduce race conditions and memory pressure in CI
          if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" != "refs/heads/main" ]; then
            echo "Testing affected packages only (PR/branch build)..."
            export TURBO_SCM_BASE="origin/$(System.PullRequest.TargetBranch)"
            echo "Running Node unit tests with coverage..."
            pnpm run test:coverage:node --affected
            echo "Running Storybook/Playwright tests with coverage..."
            pnpm run test:coverage:ui --affected
            pnpm run merge-lcov-reports
          else
            echo "Testing all packages (main branch build)..."
            export TURBO_SCM_BASE="HEAD~1"
            pnpm run test:coverage:merge
          fi
          
          # Set the merged coverage path for SonarCloud
          echo "##vso[task.setvariable variable=SONAR_LCOV_PATHS]coverage/lcov.info"
        workingDirectory: ''
      env:
        TURBO_CACHE_HIT: $(TURBO_CACHE_HIT)
        TURBO_TELEMETRY_DISABLED: 1
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)
        ${{ each pair in parameters.buildEnvSettings }}:
          ${{ pair.key }}: ${{ pair.value }}

    # Audit unused dependencies with knip (after packages are built)
    - task: Bash@3
      displayName: 'Audit unused dependencies with knip'
      condition: eq(variables['BuildJob.HAS_SOURCE_CHANGES'], 'true')
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "Running knip to detect unused dependencies..."
          pnpm knip
        workingDirectory: ''

    # Analyze dependencies with pnpm analyze
    - task: Bash@3
      displayName: 'Analyze dependencies with pnpm analyze'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "Running pnpm analyze to analyze dependencies..."
          pnpm analyze
        workingDirectory: ''

    # Audit security vulnerabilities with Snyk CLI
    - task: Bash@3
      displayName: 'Audit security vulnerabilities with Snyk CLI'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail

          # Verify environment variables
          if [ -z "$SNYK_TOKEN" ]; then
            echo "Error: SNYK_TOKEN is empty or not loaded."
            exit 1
          fi
          echo "SNYK_TOKEN PRESENT: True"

          # Authenticate Snyk CLI
          echo "Authenticating Snyk CLI..."
          pnpm exec snyk auth "$SNYK_TOKEN"

          echo "Running Snyk to detect security vulnerabilities..."
          # If PR build, run the test commands 
          if [ "$(Build.Reason)" = "PullRequest" ]; then
            echo "Authenticating Snyk for PR build..."
            pnpm run snyk
          else
            echo "Authenticating Snyk for main branch build..."
            pnpm run snyk:report
          fi
        workingDirectory: ''
      env:
        SNYK_TOKEN: $(SNYK_TOKEN)
          
          
    # Cache Java JRE
    - task: Cache@2
      displayName: 'Java: Restore JRE Cache'
      inputs:
        key: 'java | "$(Agent.OS)" | openjdk-17-jre-headless'
        restoreKeys: |
          java | "$(Agent.OS)"
        path: '/usr/lib/jvm/java-17-openjdk-amd64'
        cacheHitVar: JAVA_CACHE_HIT

    # Install Java JRE if cache is missed
    - task: Bash@3
      displayName: 'Java: Install JRE if cache missed'
      condition: ne(variables.JAVA_CACHE_HIT, 'true')
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "Installing Java 17 JRE..."
          sudo apt-get update
          sudo apt-get install -y openjdk-17-jre-headless
          java -version
          echo "JAVA_HOME set to: $JAVA_HOME"
          # Ensure JRE directory is cached
          sudo chmod -R 755 /usr/lib/jvm/java-17-openjdk-amd64
      env:
        JAVA_HOME: /usr/lib/jvm/java-17-openjdk-amd64

    # Cache SonarCloud scanner engine
    - task: Cache@2
      displayName: 'SonarCloud: Cache Scanner Engine'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        key: 'sonarcloud | "$(Agent.OS)" | scanner-engine'
        restoreKeys: |
          sonarcloud | "$(Agent.OS)"
        path: ${{parameters.SONAR_USER_HOME}}/cache
        cacheHitVar: SONAR_CACHE_HIT

    # SonarCloud analysis
    - task: Bash@3
      displayName: 'SonarCloud: Run analysis with local sonarscanner'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "Preparing SonarCloud analysis..."

          # Verify environment variables
          if [ -z "$SONAR_TOKEN" ]; then
            echo "Error: SONAR_TOKEN is empty or not loaded."
            exit 1
          fi
          echo "SONAR_TOKEN PRESENT: True"

          # Verify Java installation
          echo "Verifying Java installation..."
          java -version
          echo "JAVA_HOME: $JAVA_HOME"
          echo "SONAR_SCANNER_JAVA_PATH: $SONAR_SCANNER_JAVA_PATH"
          echo "SONAR_CACHE_HIT: $SONAR_CACHE_HIT"

          # Run SonarCloud analysis
          if [ "$(Build.Reason)" = "PullRequest" ]; then
            echo "Running SonarCloud analysis for Pull Request..."
            # Extract PR number from Build.SourceBranch
            PR_NUMBER=$(echo "$(Build.SourceBranch)" | sed -n 's|^refs/pull/\([0-9]*\)/merge$|\1|p')
            if [ -z "$PR_NUMBER" ]; then
              echo "Error: Could not extract PR number from Build.SourceBranch: $(Build.SourceBranch)"
              exit 1
            fi
            echo "PR Number: $PR_NUMBER"

            # Get branch from System.PullRequest.SourceBranch
            PR_BRANCH=$(echo "$(System.PullRequest.SourceBranch)" | sed 's|^refs/heads/||')
            if [ -z "$PR_BRANCH" ]; then
              echo "Error: System.PullRequest.SourceBranch is not set or empty: $(System.PullRequest.SourceBranch)"
              exit 1
            fi
            echo "PR Branch: $PR_BRANCH"

            pnpm run sonar -Dsonar.pullrequest.key="$PR_NUMBER" -Dsonar.pullrequest.branch="$PR_BRANCH" -Dsonar.pullrequest.base=main -Dsonar.scanner.metadataFilePath="/home/vsts/work/_temp/sonar/$(Build.BuildNumber)/report-task.txt"
          else
            echo "Running SonarCloud analysis for main branch..."
            pnpm run sonar -Dsonar.scanner.metadataFilePath="/home/vsts/work/_temp/sonar/$(Build.BuildNumber)/report-task.txt"
          fi

          # Debug: Verify report-task.txt exists
          echo "Checking for report-task.txt..."
          if [ -f "/home/vsts/work/_temp/sonar/$(Build.BuildNumber)/report-task.txt" ]; then
            echo "report-task.txt found at /home/vsts/work/_temp/sonar/$(Build.BuildNumber)/report-task.txt"
            cat "/home/vsts/work/_temp/sonar/$(Build.BuildNumber)/report-task.txt"
          else
            echo "Error: report-task.txt not found at /home/vsts/work/_temp/sonar/$(Build.BuildNumber)/report-task.txt"
            exit 1
          fi
        workingDirectory: ''
      env:
        SONAR_USER_HOME: /home/vsts/work/_temp/.sonar
        JAVA_HOME: /usr/lib/jvm/java-17-openjdk-amd64
        SONAR_SCANNER_JAVA_PATH: /usr/lib/jvm/java-17-openjdk-amd64/bin/java
        SONAR_SCANNER_SKIP_JRE_PROVISIONING: true
        SONAR_TOKEN: $(SONAR_TOKEN)

        # SonarCloud: Break the build if it doesn't pass the Quality Gate
    - task: sonarcloud-buildbreaker@2
      displayName: 'SonarCloud: Break the build if it does not pass the Quality'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        SonarCloud: ${{parameters.SonarCloud}}
        organization: ${{parameters.SonarCloud_organization}}

    # Deploy API package with production dependencies
    - task: Bash@3
      displayName: 'Artifact: Prepare API'
      condition: and(succeeded(), eq(variables['BuildJob.HAS_BACKEND_CHANGES'], 'true'), ne(variables['Build.Reason'], 'PullRequest'))
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          
          DEPLOY_DIR="$(Build.SourcesDirectory)/apps/api-deploy"
          rm -rf "$DEPLOY_DIR"
          
          echo "Creating production deployment for @sthrift/api..."

          # Use pnpm deploy to resolve workspace dependencies while preserving pnpm symlinks
          # This copies everything including dist/, host.json, and installs production deps
          # Using --legacy flag to maintain pnpm v9 behavior with v10+
          # Rationale: The --legacy flag is required to preserve pnpm v9 workspace symlink behavior during deployment.
          # Specifically, pnpm v10+ changes how workspace dependencies are resolved and symlinked, which can break
          # our deployment artifact structure and runtime resolution. Until our deployment scripts and runtime
          # are verified to work with the new pnpm v10+ behavior, we retain --legacy to ensure:
          #   - Workspace dependencies are symlinked as in pnpm v9
          #   - The node_modules structure matches what our runtime expects
          # @CellixJs/tech-sme: Please reassess the need for --legacy when upgrading pnpm or changing deployment logic.
          pnpm --filter @sthrift/api --prod deploy --legacy "$DEPLOY_DIR"
          
          # Remove unnecessary files that pnpm deploy copied
          rm -rf "$DEPLOY_DIR"/{.turbo,coverage,tests,.vscode,.github,.gitignore,README.md,src}
          
          # Verify deployment structure
          echo ""
          echo "✓ Production API structure:"
          ls -lah "$DEPLOY_DIR"
          
          # Verify critical files exist
          echo ""
          echo "✓ Verifying required files..."
          for file in package.json host.json dist node_modules; do
            if [ ! -e "$DEPLOY_DIR/$file" ]; then
              echo "ERROR: Required file/directory missing: $file"
              exit 1
            fi
            echo "  ✓ $file"
          done
          
          echo ""
          echo "✓ Production API package ready for archiving"

          # Create the zip artifact while preserving pnpm symlinks
          ZIP_PATH="$(Build.ArtifactStagingDirectory)/api-$(Build.BuildId).zip"
          mkdir -p "$(Build.ArtifactStagingDirectory)"
          rm -f "$ZIP_PATH"

          echo ""
          echo "✓ Creating symlink-aware zip archive..."
          pushd "$DEPLOY_DIR" >/dev/null
          zip --symlinks -q -r "$ZIP_PATH" .
          popd >/dev/null
          echo "✓ API artifact created at: $ZIP_PATH"
        workingDirectory: ''

    # Package UI ShareThrift compiled assets into artifact
    - task: ArchiveFiles@2
      displayName: 'Artifact: Prepare UI ShareThrift'
      condition: and(succeeded(), eq(variables['BuildJob.HAS_FRONTEND_CHANGES'], 'true'), ne(variables['Build.Reason'], 'PullRequest'))
      inputs:
        rootFolderOrFile: 'apps/ui-sharethrift/dist'
        includeRootFolder: false
        archiveType: zip
        archiveFile: $(Build.ArtifactStagingDirectory)/ui-sharethrift-$(Build.BuildId).zip
        replaceExistingArchive: true

    # Package Docs compiled assets into artifact
    - task: ArchiveFiles@2
      displayName: 'Artifact: Prepare Docs'
      condition: and(succeeded(), eq(variables['BuildJob.HAS_DOCS_CHANGES'], 'true'), ne(variables['Build.Reason'], 'PullRequest'))
      inputs:
        rootFolderOrFile: 'apps/docs/build'
        includeRootFolder: false
        archiveType: zip
        archiveFile: $(Build.ArtifactStagingDirectory)/docs-$(Build.BuildId).zip
        replaceExistingArchive: true

    # Upload API artifact as build result
    - publish: $(Build.ArtifactStagingDirectory)/api-$(Build.BuildId).zip
      displayName: 'Artifact: Publish API'
      condition: and(succeeded(), eq(variables['BuildJob.HAS_BACKEND_CHANGES'], 'true'), ne(variables['Build.Reason'], 'PullRequest'))
      artifact: api

    # Upload UI ShareThrift artifact as build result
    - publish: $(Build.ArtifactStagingDirectory)/ui-sharethrift-$(Build.BuildId).zip
      displayName: 'Artifact: Publish UI ShareThrift'
      condition: and(succeeded(), eq(variables['BuildJob.HAS_FRONTEND_CHANGES'], 'true'), ne(variables['Build.Reason'], 'PullRequest'))
      artifact: ui-sharethrift

    # Upload Docs artifact as build result
    - publish: $(Build.ArtifactStagingDirectory)/docs-$(Build.BuildId).zip
      displayName: 'Artifact: Publish Docs'
      condition: and(succeeded(), eq(variables['BuildJob.HAS_DOCS_CHANGES'], 'true'), ne(variables['Build.Reason'], 'PullRequest'))
      artifact: docs